<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Three_Leap</title>
  <script src="http://js.leapmotion.com/leap-0.6.4.js"></script>

  <script src="http://js.leapmotion.com/leap-plugins-0.1.11.js"></script>
  <script src="http://js.leapmotion.com/leap-widgets-0.1.0.min.js"></script>
  <script src="http://js.leapmotion.com/leap.rigged-hand-0.1.7.js"></script>


  <script src="js/Three.js"></script>
  <script>src="js/OrbitControls.js"</script>

  <script></script>
  <!-- /*<style>
    canvas {
      position: fixed;
      top: 0;
      left: 0;
    }
  </style>*/ -->

  <style>
    body {
      margin: 0;
    }
    canvas.leap-boneHAnd{
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #view-source {
      position: absolute;
      top: 0;
      right: 0;
      margin: 10px;
      z-index: 10;
    }
  </style>



</head>

<body>




</body>

  <script>

  'use strict';

  // Set up plugins

  Leap.loop({background: true})
    .use('transform', {
      vr: 'desktop' // Switch to meters.
    })
    .use('boneHand', {
      targetEl: document.body,
      jointColor: new THREE.Color(0xffffff),
      rendererOps: {antialias: true}
    })
    .use('proximity');


  // Set up scene

  var scene = Leap.loopController.plugins.boneHand.scene;
  var camera = Leap.loopController.plugins.boneHand.camera;
  var renderer = Leap.loopController.plugins.boneHand.renderer;
  camera.position.set( 0, 0.3, 0.6 );

  var controls = new THREE.OrbitControls( camera );

  var axisHelper = new THREE.AxisHelper( 0.1 );
  scene.add( axisHelper );

  // Add a plane

  var planeGeo = new THREE.PlaneGeometry(0.1, 0.2);
  var material = new THREE.MeshPhongMaterial();
  var buttonMesh = new THREE.Mesh(planeGeo, material);

  buttonMesh.name = "rectangular button";

//  buttonMesh.scale.setY(0.5);


  var longThrow = -0.1;
  var squareButton = new PushButton(

    new InteractablePlane(buttonMesh, Leap.loopController),

    {
      locking: false,
      longThrow: longThrow
    }

  ).on('press', function(mesh){

    mesh.material.color.setHex(0xccccff);

  }).on('release', function(mesh){

    mesh.material.color.setHex(0xeeeeee);

  });

  squareButton.plane.hover(
    function(mesh){ // over
      console.log('hover in');
      mesh.material.color.setHex(0xffccff);
    },
    function(mesh){ // out
      console.log('hover out');
      mesh.material.color.setHex(0xeeeeee);
    }
  );


  var base = new THREE.Mesh(new THREE.BoxGeometry(0.1, longThrow, longThrow), new THREE.MeshPhongMaterial({color: 0x222222}));
  base.position.set(0.05, 0, -0.1);
  base.rotateY(Math.PI * -0.15);

  buttonMesh.position.set(
    0,
    buttonMesh.geometry.parameters.height / 2 - longThrow / 2,
    -longThrow / 2
  );
  squareButton.plane.resetPosition(); // resets the original position, etc to the current one

//  base.rotateX(Math.PI * -0.45);
//  base.position.set(0.2,0,0.2);

  base.add(buttonMesh);

  scene.add(base);


  // Circular button:

  var circleGeo = new THREE.CircleGeometry(0.1, 32);
  buttonMesh = new THREE.Mesh(circleGeo, material.clone());
  buttonMesh.name = "round button";

  buttonMesh.position.set(-0.12, 0.1, -0.1);
  scene.add(buttonMesh);

  var roundButton = new PushButton(
    // for now, constructing with moveX and moveY turned off so that doesn't try and watch for XY intersections,
    // which won't work for circles.
    // todo - have a setter for moveX and moveY, so that proximities can be turned on and off.
    // Note that we have to bind press and release effects to each individual button. This is a long way from CSS rules still.
    new InteractablePlane(buttonMesh, Leap.loopController, {moveX: false, moveY: false})
  ).on('press', function(mesh){

    mesh.material.color.setHex(0xccccff);

  }).on('release', function(mesh){

    mesh.material.color.setHex(0xeeeeee);

  });



  document.getElementById('view-source').href = "view-source:" + window.location.href;
  document.getElementById('view-source').target = "_blank";

 //  // Set up plugins
 //
 //   'use strict';
 //
 //   Leap.loop({background: true})
 //     .use('transform', {
 //       vr: 'desktop' // Switch to meters.
 //     })
 //     .use('boneHand', {
 //       targetEl: document.body,
 //       jointColor: new THREE.Color(0xffffff),
 //       rendererOps: {antialias: true}
 //     })
 //     .use('proximity');
 //
 //
 //   // Set up scene
 //
 //   var scene = Leap.loopController.plugins.boneHand.scene;
 //   var camera = Leap.loopController.plugins.boneHand.camera;
 //   var renderer = Leap.loopController.plugins.boneHand.renderer;
 //   camera.position.set( 0, 0.3, 0.6);
 //
 //   var controls = new THREE.OrbitControls( camera, renderer.domElement );
 //
 //   var axisHelper = new THREE.AxisHelper( 0.1 );
 //   scene.add( axisHelper );
 //
 //
 //
 //
 //   document.getElementById('view-source').href = "view-source:" + window.location.href;
 //  document.getElementById('view-source').target = "_blank";
 // //
 // //
 // //
 // //   var planeGeo = new THREE.PlaneGeometry(0.1, 0.2);
 // //  var material = new THREE.MeshPhongMaterial({side: THREE.DoubleSide});
 // //  var planeMesh = new THREE.Mesh(planeGeo, material);
 // //  planeMesh.position.setX(0.05);
 // //  planeMesh.position.setY(0.1);
 // //  planeMesh.name = "planeMesh";
 // //
 // //
 // //
 // //  planeMesh.position.set( 0, planeMesh.geometry.parameters.height / 2 - longThrow / 2, longThrow / 2 + 0.0002 );
 // // base.add(planeMesh);
 // //
 // // scene.add(base);
 // //
 // // var plane = new InteractablePlane(planeMesh, Leap.loopController, {moveZ: true, moveX: false, moveY: false});
 // //
 // // document.getElementById('view-source').href = "view-source:" + window.location.href;
 // //   document.getElementById('view-source').target = "_blank";
 //
 //
 //
 //
 //
 //
 //    // var width = window.innerWidth;
 //    // var height = window.innerHeight;
 //    //
 //    // var clock = new THREE.Clock;
 //    //
 //    //
 //    // var renderer = new THREE.WebGLRenderer({
 //    //   antialias: true
 //    // });
 //    // renderer.setSize(width, height);
 //    // document.body.appendChild(renderer.domElement);
 //    //
 //    // var scene = new THREE.Scene;
 //
 //
 //
 //
 //
 //    var planeMesh = new THREE.Mesh(
 //      new THREE.PlaneGeometry(0.1, 0.2),
 //      new THREE.MeshPhongMaterial()
 //    );
 //    scene.add(planeMesh);
 //
 //    var plane = new InteractablePlane(planeMesh, Leap.loopController);




    // var planeGeometry = new THREE.PlaneGeometry(100,100,100);
    // var planeMaterial = new THREE.MeshBasicMaterial({ color: 0x1ec876})
    //
    // var planeMesh = new THREE.Mesh(planeGeometry,planeMaterial);
    //
    //
    //
    // //var plane = new InteractablePlane(planeMesh, Leap.loopController, {moveZ: true, moveX: false, moveY: false});
    // scene.add(planeMesh)



    // plane.translateX(2);
    // plane.translateZ(30)






    // var cubeGeometry = new THREE.CubeGeometry(100, 100, 100);
    // var cubeMaterial = new THREE.MeshLambertMaterial({
    //   color: 0x1ec876
    // });
    //
    //
    // var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    //
    // cube.rotation.y = Math.PI * 45 / 180;
    //
    // scene.add(cube);


  //
  //   var camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
  //   camera.position.y = 160;
  //   camera.position.z = 400;
  //
  //   scene.add(camera);
  //
  //   var skyboxGeometry = new THREE.PlaneGeometry(10000, 10000, 10000);
  //   var skyboxMaterial = new THREE.MeshBasicMaterial({
  //     color: 0x000000,
  //     side: THREE.BackSide
  //   });
  //   var skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
  //   scene.add(skybox);
  //
  //
  //
  //   //renderer.render(scene, camera);
  //   camera.lookAt(plane.position);
  //
  //
  //
  //
  //
  //
  //   var pointLight = new THREE.PointLight(0xffffff);
  //   pointLight.position.set(0, 300, 200);
  //
  //   scene.add(pointLight);
  //
  //
  //
  //
  //
  //
  //   function render() {
  //     renderer.render(scene, camera);
  //   //plane.rotation.y -= clock.getDelta();
  //
  //
  //   requestAnimationFrame(render);
  //   }
  //
  // //  renderer.render(scene, camera);
  //
  //
  //   render();


  </script>




</html>
